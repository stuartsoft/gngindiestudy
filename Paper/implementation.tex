\section{Genetic Algorithm Overview}
	Our A* waypoint system began with several guidelines and constraints around which to model a genetic algorithm. These guidelines would dictate the type of graph we wished to achieve from running our genetic algorithm. Having understood A* search itself, an ideal waypoint graph should only contain the \textbf{minimum number of nodes} required to quickly and efficiently traverse the maze through the search. Secondly, the graph should aim to achieve \textbf{full connectivity} of the maze's walkable space, meaning that any random point placed in the maze should be walkable to any other point in the maze by running A* search using the generated graph.
	
	With the attributes of an ideal A* waypoint graph in mind, we next considered the construction of a genetic algorithm to handle the evolution sequence for generating such a graph.
	
	\subsection{Initial Population}
	The initial starting population contained a set of \(x\) graphs, each of which would be generated using \(y\) randomly placed nodes in the walkable space of the graph. Each node in this set would be connected to every other node where line of sight visibility was present. Line of sight, for the purpose of this algorithm, was handled by Unity Engine's raycasting system. This means that for any given nodes \(a\) and \(b\) in the graph, such that \(a \neq b\), if a ray could be cast from \(a\) to \(b\) without intersecting with any wall of the maze, then \(a\) and \(b\) should be connected. The resulted in a fully connected graph along all walkable edges in the graph.
	
	\subsection{Evaluation}
	After the initial generation has been built, the genetic algorithm must then handle evaluating each graph, evaluating fitness for use later in the selection and crossover stages. Three immediate factors were used to score graphs in this implementation. The first, and most obvious factor, was the \textbf{graph's node count}. Lower node counts result in A* running faster and requiring fewer traversals of adjacent nodes. The second characteristic scored was the graph's overall \textbf{A* satisfaction rating}. This rating was computed by randomly placing 100 starting and ending points in the graph's walkable space. An A* search was then attempted on each of these pairs using the given waypoint graph, with the resulting satisfaction rating representing the percentage of successful A* paths that could be traced from the pool of 100 pairs of points. It is important to note that a fresh set of 100 random starting/ending points were cycled with each new generation, preventing the graph from becoming ``overly fit" for just one set of A* maze traversals. The third attribute measured on each graph was the \textbf{average length of successful A* path traces} from the A* satisfaction rating evaluation. This value indicates how successful the given graph is at effectively traversing the maze. Lower A* path lengths mean that A* is able to traverse the graph much more efficiently, taking more direct paths from start to finish. To simplify the crossover and tuning stages, the overall heuristic score was stricly limited to the A* satisfaction rating, however further tuning could be made by setting the heuristic score to a weighted combination of both A* satisfaction and average path length.
	
	\subsection{Selection and Crossover}
	With the population evaluated and sorted by fitness, the algorithm can then go through the list of graphs and begin breeding. The breeding system involves systematically running through the population and ``mating" the most fit graphs first. The process continues until enough offspring have been generated to replace the previous population. If every graph in the current population has had a chance to breed but there are not enough offspring to replace their elders, the process will start again with the two most fit graphs.
	
	The breeding process itself between to graphs is as follows. Parent graph \(a\) and \(b\) are both checked for their A* satisfaction rating. Let \(k\) represent the percentage of crossover nodes to be removed from the breeding process. By cycling out a certain percentage of nodes during each breeding phase, inbreeding is prevented and additional diversity of graphs are reintroduced at each breeding stage. Let \(p\) represent the higher of these two A* satisfaction values. Let \(N\) represent the total number of nodes in parent graph \(a\). The new child graph \(c\) is then creating using a randomly selected node \(n1\) from graph \(a\) and a randomly selected node \(n2\) from graph \(b\) (provided that \(n1\) and \(n2\) have not previously been selected from \(a\) and \(b\) respectively). Nodes are randomly selected from \(a\) and \(b\) until graph \(c\) contains \((N*(1-k))/2)\) Finally, the new graph is given a boost of new nodes, up to \((1-p)*N * normally distributed random floats\) This step also allows the graphs to grow (or shrink) from one generation to the next and introduces graph diversity.

\section{Implementation and Tuning}